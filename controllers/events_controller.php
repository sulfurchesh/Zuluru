<?php
class EventsController extends AppController {

	var $name = 'Events';
	var $components = array('Lock', 'CanRegister');

	function publicActions() {
		return array('cron', 'index', 'view', 'wizard');
	}

	function isAuthorized() {
		// Anyone that's logged in can perform these operations
		if (in_array ($this->params['action'], array(
				'count',
		)))
		{
			return true;
		}

		if ($this->is_manager) {
			// Managers can perform these operations
			if (in_array ($this->params['action'], array(
					'add',
					'event_type_fields',
			)))
			{
				return true;
			}

			// Managers can perform these operations in affiliates they manage
			if (in_array ($this->params['action'], array(
					'edit',
					'connections',
					'delete',
			)))
			{
				// If an event id is specified, check if we're a manager of that event's affiliate
				$event = $this->_arg('event');
				if ($event) {
					if (in_array($this->Event->affiliate($event), $this->UserCache->read('ManagedAffiliateIDs'))) {
						return true;
					}
				}
			}
		}

		return false;
	}

	function index() {
		if ($this->is_admin || $this->is_manager) {
			// Admins and managers see things that have recently close, or open far in the future
			$close = 'DATE_ADD(CURDATE(), INTERVAL -30 DAY)';
			$open = 'DATE_ADD(CURDATE(), INTERVAL 180 DAY)';
		} else {
			$close = 'CURDATE()';
			$open = 'DATE_ADD(CURDATE(), INTERVAL 30 DAY)';
		}

		if (empty($this->params['requested'])) {
			$affiliates = $this->_applicableAffiliateIDs();
		} else {
			$affiliates = $this->_applicableAffiliateIDs(true);
		}

		$events = $this->Event->find('all', array(
			'conditions' => array(
				"Event.open < $open",
				"Event.close > $close",
				'Event.affiliate_id' => $affiliates,
			),
			'order' => array('Affiliate.name', 'Event.event_type_id', 'Event.open', 'Event.close', 'Event.id'),
			'contain' => array(
				'EventType',
				'Affiliate',
				'Price' => array('order' => array('Price.open', 'Price.close', 'Price.id')),
				'Division' => array('League', 'Day')
			),
		));

		if (!empty($this->params['requested'])) {
			return $events;
		}

		$this->set(compact('affiliates', 'events'));
	}

	function wizard($step = null) {
		if (!$this->is_logged_in) {
			$this->redirect(array('action' => 'index'));
		}
		$id = $this->Auth->user('zuluru_person_id');

		if (in_array($this->UserCache->read('Person.status'), array('inactive', 'locked'))) {
			$this->Session->setFlash(__('Your account is currently inactive, please contact an administrator to reactivate it.', true), 'default', array('class' => 'info'));
			$this->redirect('/');
		}

		// Check whether this user is considered active for the purposes of registration
		$is_active = ($this->UserCache->read('Person.status') == 'active');
		// If the user is not yet approved, we may let them register but not pay
		if ($this->UserCache->read('Person.status') == 'new' && Configure::read('registration.allow_tentative')) {
			$person = array(
				'Person' => $this->UserCache->read('Person'),
				'Affiliate' => $this->UserCache->read('Affiliates'),
			);
			$duplicates = $this->Event->Registration->Person->findDuplicates ($person);
			if (empty ($duplicates)) {
				$is_active = true;
			}
		}
		if (!$is_active) {
			$this->Session->setFlash(__('You are not allowed to register for events until your account has been approved.', true), 'default', array('class' => 'info'));
			$this->redirect('/');
		}

		// Find any preregistrations
		$prereg = $this->Event->Preregistration->find('list', array(
			'conditions' => array('person_id' => $id),
			'fields' => array('id', 'event_id'),
		));

		// Find all the events that are potentially available
		// TODO: Eliminate the events that don't match the step, if any
		$affiliates = $this->_applicableAffiliateIDs();
		$events = $this->Event->find('all', array(
			'conditions' => array(
				'OR' => array(
					array(
						'Event.open < DATE_ADD(CURDATE(), INTERVAL 30 DAY)',
						'Event.close > CURDATE()',
					),
					'Event.id' => $prereg,
				),
				'Event.affiliate_id' => $affiliates,
			),
			'order' => array('Event.event_type_id', 'Event.open', 'Event.close', 'Event.id'),
			'contain' => array(
				'EventType',
				'Affiliate',
				'Price' => array('order' => array('Price.open', 'Price.close', 'Price.id')),
				'Division' => array('League', 'Day')
			),
		));

		$types = $this->Event->EventType->find('all', array(
			'order' => array('EventType.id'),
		));

		// Prune out the events that are not possible
		foreach ($events as $key => $event) {
			$test = $this->CanRegister->test ($id, $event, array('strict' => false, 'waiting' => true));
			if (!$test['allowed']) {
				unset ($events[$key]);
			}
		}

		$this->set(compact('events', 'types', 'affiliates', 'step'));
	}

	function view() {
		$id = $this->_arg('event');
		if (!$id) {
			$this->Session->setFlash(sprintf(__('Invalid %s', true), __('event', true)), 'default', array('class' => 'info'));
			$this->redirect(array('action' => 'wizard'));
		}

		if ($this->is_manager && !in_array($this->Event->affiliate($id), $this->UserCache->read('ManagedAffiliateIDs'))) {
			$this->is_manager = false;
		}
		if ($this->is_admin || $this->is_manager) {
			// Admins and managers see things that have recently close, or open far in the future
			$close = 'DATE_ADD(CURDATE(), INTERVAL -30 DAY)';
			$open = 'DATE_ADD(CURDATE(), INTERVAL 180 DAY)';
		} else {
			$close = 'CURDATE()';
			$open = 'DATE_ADD(CURDATE(), INTERVAL 30 DAY)';
		}

		$this->Event->contain (array(
			'EventType',
			'Price' => array('order' => array('Price.open', 'Price.close', 'Price.id')),
			'Division' => array(
				'DivisionGameslotAvailability' => array(
					'GameSlot' => array(
						'Field' => 'Facility',
					),
				),
				'Day',
				'Event' => array(
					'EventType',
					'conditions' => array('Event.id !=' => $id),
				),
			),
			'Alternate' => array(
				'EventType',
				'conditions' => array(
					"Alternate.open < $open",
					"Alternate.close > $close",
				),
			),
			'Affiliate',
		));
		$event = $this->Event->read(null, $id);
		if (!$event) {
			$this->Session->setFlash(sprintf(__('Invalid %s', true), __('event', true)), 'default', array('class' => 'info'));
			$this->redirect(array('action' => 'wizard'));
		}
		$this->Configuration->loadAffiliate($event['Event']['affiliate_id']);

		// Extract some more details, if it's a division registration
		if (!empty($event['Event']['division_id'])) {
			// Find the list of facilities and time slots
			$facilities = $times = array();
			if (!empty($event['Division']['DivisionGameslotAvailability'])) {
				foreach ($event['Division']['DivisionGameslotAvailability'] as $avail) {
					$slot = $avail['GameSlot'];
					$facilities[$slot['Field']['Facility']['id']] = $slot['Field']['Facility']['name'];
					$times[$slot['game_start']] = $slot['game_end'];
				}
				asort ($times);
			}
		}

		if ($this->is_logged_in) {
			$this->set ($this->CanRegister->test ($this->Auth->user('zuluru_person_id'), $event, array('all_rules' => true)));
		}

		$affiliates = $this->_applicableAffiliateIDs(true);
		$this->set(compact ('id', 'event', 'facilities', 'times', 'affiliates'));
	}

	function add() {
		if (!empty($this->data)) {
			// Validation requires this information
			$type = $this->Event->EventType->read(null, $this->data['Event']['event_type_id']);
			if (!$type) {
				// We need something here to avoid errors
				$type = array('EventType' => array('type' => null));
			}
			$this->data = array_merge ($this->data, $type);

			$this->Event->create();

			$transaction = new DatabaseTransaction($this->Event);
			if ($this->Event->save($this->data)) {
				$this->data['Price']['event_id'] = $this->Event->id;
				if ($this->Event->Price->save($this->data['Price'])) {
					$transaction->commit();
					$this->Session->setFlash(sprintf(__('The %s has been saved', true), __('event', true)), 'default', array('class' => 'success'));
					$this->redirect(array('action' => 'index'));
				}
			} else {
				$this->Session->setFlash(sprintf(__('The %s could not be saved. Please correct the errors below and try again.', true), __('event', true)), 'default', array('class' => 'warning'));
				$this->Configuration->loadAffiliate($this->data['Event']['affiliate_id']);
			}
		} else {
			// Set up defaults
			$this->data = array('EventType' => array(
					'type' => 'generic',
			));
		}

		$affiliates = $this->_applicableAffiliates(true);
		$this->set('eventTypes', $this->Event->EventType->find('list'));
		$this->set('questionnaires', $this->Event->Questionnaire->find('list', array('conditions' => array(
				'Questionnaire.active' => true,
				'Questionnaire.affiliate_id' => array_keys($affiliates),
		))));
		$this->set('event_obj', $this->_getComponent ('EventType', $this->data['EventType']['type'], $this));
		$this->set(compact('affiliates'));
		$this->set('add', true);

		if (Configure::read('feature.tiny_mce')) {
			$this->helpers[] = 'TinyMce.TinyMce';
		}

		$this->render ('edit');
	}

	function edit() {
		$id = $this->_arg('event');
		if (!$id && empty($this->data)) {
			$this->Session->setFlash(sprintf(__('Invalid %s', true), __('event', true)), 'default', array('class' => 'info'));
			$this->redirect(array('action' => 'index'));
		}
		if (!empty($this->data)) {
			// Validation requires this information
			$type = $this->Event->EventType->read(null, $this->data['Event']['event_type_id']);
			if (!$type) {
				// We need something here to avoid errors
				$type = array('EventType' => array('type' => null));
			}
			$this->data = array_merge ($this->data, $type);

			$transaction = new DatabaseTransaction($this->Event);
			if ($this->Event->save($this->data) && $this->Event->Price->save($this->data)) {
				$transaction->commit();
				$this->Session->setFlash(sprintf(__('The %s has been saved', true), __('event', true)), 'default', array('class' => 'success'));
				$this->redirect(array('action' => 'index'));
			} else {
				$this->Session->setFlash(sprintf(__('The %s could not be saved. Please correct the errors below and try again.', true), __('event', true)), 'default', array('class' => 'warning'));
				$this->Configuration->loadAffiliate($this->Event->affiliate($id));
			}
		}
		if (empty($this->data)) {
			$this->Event->contain (array (
				'EventType',
				'Price' => array('order' => array('Price.open', 'Price.close', 'Price.id')),
			));
			$this->data = $this->Event->read(null, $id);
			if (!$this->data) {
				$this->Session->setFlash(sprintf(__('Invalid %s', true), __('event', true)), 'default', array('class' => 'info'));
				$this->redirect(array('action' => 'index'));
			}
			$this->Configuration->loadAffiliate($this->data['Event']['affiliate_id']);

			if (count($this->data['Price']) == 1) {
				// Adjust loaded data
				$this->data['Price'] = array_pop($this->data['Price']);
			}
		}

		$affiliates = $this->_applicableAffiliates(true);
		$this->set('eventTypes', $this->Event->EventType->find('list'));
		$this->set('questionnaires', $this->Event->Questionnaire->find('list', array('conditions' => array(
				'Questionnaire.active' => true,
				'Questionnaire.affiliate_id' => array_keys($affiliates),
		))));
		$this->set('event_obj', $this->_getComponent ('EventType', $this->data['EventType']['type'], $this));
		$this->set(compact('affiliates'));

		if (Configure::read('feature.tiny_mce')) {
			$this->helpers[] = 'TinyMce.TinyMce';
		}
	}

	function event_type_fields() {
		Configure::write ('debug', 0);
		$this->layout = 'ajax';
		$this->Event->contain (array (
			'EventType',
		));
		$type = $this->Event->EventType->read(null, $this->params['url']['data']['Event']['event_type_id']);
		$this->set('event_obj', $this->_getComponent ('EventType', $type['EventType']['type'], $this));
		$this->set('affiliates', $this->_applicableAffiliates(true));
	}

	function delete() {
		$id = $this->_arg('event');
		if (!$id) {
			$this->Session->setFlash(sprintf(__('Invalid %s', true), __('event', true)), 'default', array('class' => 'info'));
			$this->redirect(array('action' => 'index'));
		}
		$dependencies = $this->Event->dependencies($id);
		if ($dependencies !== false) {
			$this->Session->setFlash(__('The following records reference this event, so it cannot be deleted.', true) . '<br>' . $dependencies, 'default', array('class' => 'warning'));
			$this->redirect(array('action'=>'index'));
		}
		if ($this->Event->delete($id)) {
			$this->Session->setFlash(sprintf(__('%s deleted', true), __('Event', true)), 'default', array('class' => 'success'));
			$this->redirect(array('action' => 'index'));
		}
		$this->Session->setFlash(sprintf(__('%s was not deleted', true), __('Event', true)), 'default', array('class' => 'warning'));
		$this->redirect(array('action' => 'index'));
	}

	function connections() {
		$id = $this->_arg('event');
		if (!$id) {
			$this->Session->setFlash(sprintf(__('Invalid %s', true), __('event', true)), 'default', array('class' => 'info'));
			$this->redirect(array('action' => 'index'));
		}

		if (!empty($this->data)) {
			$transaction = new DatabaseTransaction($this->Event->EventsConnection);
			$success = true;

			// Alternates always go both ways
			$this->data['Event']['AlternateTo'] = $this->data['Event']['Alternate'];

			foreach (Configure::read('event_connection') as $type => $name) {
				$save = array();
				$success &= $this->Event->EventsConnection->deleteAll(array(
						'event_id' => $id,
						'connection' => $type,
				));
				$success &= $this->Event->EventsConnection->deleteAll(array(
						'connected_event_id' => $id,
						'connection' => $type,
				));

				if (!empty($this->data['Event'][$name])) {
					foreach ($this->data['Event'][$name] as $connection) {
						$save[] = array(
							'event_id' => $id,
							'connection' => $type,
							'connected_event_id' => $connection,
						);
					}
				}

				if (!empty($this->data['Event'][$name . 'To'])) {
					foreach ($this->data['Event'][$name . 'To'] as $connection) {
						$save[] = array(
							'event_id' => $connection,
							'connection' => $type,
							'connected_event_id' => $id,
						);
					}
				}

				if (!empty($save)) {
					$success &= $this->Event->EventsConnection->saveAll($save);
				}
			}
			if ($success) {
				$transaction->commit();
				$this->Session->setFlash(sprintf(__('The %s have been saved', true), __('connections', true)), 'default', array('class' => 'success'));
				$this->redirect(array('action' => 'view', 'event' => $id));
			} else {
				$this->Session->setFlash(sprintf(__('The %s could not be saved. Please correct the errors below and try again.', true), __('connections', true)), 'default', array('class' => 'warning'));
			}
		}

		if (empty($this->data)) {
			$this->Event->contain (array(
				'Predecessor',
				'Successor',
				'Alternate',
				'PredecessorTo',
				'SuccessorTo',
			));
			$this->data = $this->Event->read(null, $id);
			if (!$this->data) {
				$this->Session->setFlash(sprintf(__('Invalid %s', true), __('event', true)), 'default', array('class' => 'info'));
				$this->redirect(array('action' => 'index'));
			}
		}

		$events = $this->Event->find('all', array(
			'conditions' => array(
				'Event.id !=' => $id,
				"Event.open > DATE_ADD('{$this->data['Event']['open']}', INTERVAL -18 MONTH)",
				"Event.open < DATE_ADD('{$this->data['Event']['open']}', INTERVAL 18 MONTH)",
				"Event.close > DATE_ADD('{$this->data['Event']['close']}', INTERVAL -18 MONTH)",
				"Event.close < DATE_ADD('{$this->data['Event']['close']}', INTERVAL 18 MONTH)",
				'Event.affiliate_id' => $this->data['Event']['affiliate_id'],
			),
			'order' => array('Event.event_type_id', 'Event.open', 'Event.close', 'Event.id'),
			'fields' => array('Event.id', 'Event.name', 'Event.open', 'Event.close', 'Event.event_type_id'),
			'contain' => array('EventType'),
		));
		$event_types = $this->Event->EventType->find('list');

		$this->set(compact('events', 'event_types'));
	}

	function count($membership = false) {
		if (!Configure::read('feature.registration')) {
			return 0;
		}

		$conditions = array(
			'open < CURDATE()',
			'close > CURDATE()',
			'affiliate_id' => $this->_applicableAffiliateIDs(),
		);
		$membership_types = $this->Event->EventType->find('list', array(
			'conditions' => array('type' => 'membership'),
			'fields' => array('id', 'id'),
		));
		if ($membership) {
			$conditions['event_type_id'] = $membership_types;
		} else {
			$conditions['NOT'] = array('event_type_id' => $membership_types);
		}

		return $this->Event->find('count', array(
				'conditions' => $conditions,
				'contain' => array(),
		));
	}

	function cron() {
		if (!Configure::read('feature.registration')) {
			return;
		}

		$this->layout = 'bare';
		if (!ini_get('safe_mode')) { 
			set_time_limit(1800);
		}

		if (!$this->Lock->lock ('cron')) {
			return false;
		}
		$transaction = new DatabaseTransaction($this->Event);

		// Update any event open and close dates that have changed because of prices
		// being added or edited
		$prices = $this->Event->Price->find('all', array(
				'conditions' => array('OR' => array(
					'Price.open != Event.open',
					'Price.close != Event.close',
				)),
				'contain' => 'Event',
		));

		$events = array();
		foreach ($prices as $price) {
			if (!array_key_exists($price['Price']['event_id'], $events)) {
				$events[$price['Price']['event_id']] = array(
					'id' => $price['Price']['event_id'],
					'open' => $price['Price']['open'],
					'close' => $price['Price']['close'],
				);
			} else {
				$events[$price['Price']['event_id']]['open'] = min($events[$price['Price']['event_id']]['open'], $price['Price']['open']);
				$events[$price['Price']['event_id']]['close'] = max($events[$price['Price']['event_id']]['close'], $price['Price']['close']);
			}
		}
		foreach ($events as $id => $event) {
			$saved = Set::extract("/Event[id=$id]", $prices);
			if ($saved[0]['Event']['open'] == $event['open'] && $saved[0]['Event']['close'] == $event['close']) {
				unset($events[$id]);
			}
		}
		if (!empty($events)) {
			$this->Event->saveAll ($events);
		}

		$transaction->commit();

		if (!Configure::read('feature.badges')) {
			$this->Lock->unlock();
			return;
		}

		$badges = $this->Event->Registration->Person->Badge->find('all', array(
				'conditions' => array(
					'Badge.category' => 'registration',
					'Badge.active' => true,
				),
				'contain' => array(),
		));
		if (empty($badges)) {
			$this->Lock->unlock();
			return;
		}
		$badge_obj = $this->_getComponent('badge', '', $this);
		$transaction = new DatabaseTransaction($this->Event);

		$activity_log = ClassRegistry::init('ActivityLog');
		$today = date('Y-m-d');

		// Find all membership events for which the membership has started,
		// but we haven't opened it. The only ones that can possibly be
		// opened are ones that are closed, but not even all of those will be.
		$events = $this->Event->find('all', array(
				'conditions' => array(
					'NOT' => array('id' => $activity_log->find('list', array(
						'conditions' => array('type' => 'membership_opened'),
						'fields' => array('id', 'custom'),
					))),
					'open <= CURDATE()',
					'affiliate_id' => $this->_applicableAffiliateIDs(),
					'event_type_id' => $this->Event->EventType->find('list', array(
						'conditions' => array('type' => 'membership'),
						'fields' => array('id', 'id'),
					)),
				),
				'contain' => array(),
		));

		foreach ($events as $event) {
			if ($event['Event']['membership_begins'] <= $today) {
				$this->Event->contain(array('Registration' => array(
						'conditions' => array('Registration.payment' => Configure::read('registration_paid')),
				)));
				$event = $this->Event->read(null, $event['Event']['id']);
				foreach ($event['Registration'] as $person) {
					// We are only dealing with paid and pending registrations, so the $extra parameter is true
					$badge_obj->update('registration', array('Registration' => $person), true);
				}
				$activity_log->create();
				$activity_log->save(array('type' => 'membership_opened', 'custom' => $event['Event']['id']));
			}
		}

		// Find all membership events for which the membership has ended,
		// but we haven't closed it. The only ones that can possibly be
		// ended are ones that are closed, but not even all of those will be.
		$events = $this->Event->find('all', array(
				'conditions' => array(
					'NOT' => array('id' => $activity_log->find('list', array(
						'conditions' => array('type' => 'membership_closed'),
						'fields' => array('id', 'custom'),
					))),
					'close < CURDATE()',
					'affiliate_id' => $this->_applicableAffiliateIDs(),
					'event_type_id' => $this->Event->EventType->find('list', array(
						'conditions' => array('type' => 'membership'),
						'fields' => array('id', 'id'),
					)),
				),
				'contain' => array(),
		));

		foreach ($events as $event) {
			if ($event['Event']['membership_ends'] < $today) {
				$this->Event->contain(array('Registration' => array(
						'conditions' => array('Registration.payment' => Configure::read('registration_paid')),
				)));
				$event = $this->Event->read(null, $event['Event']['id']);
				foreach ($event['Registration'] as $person) {
					// We are only dealing with paid and pending registrations, so the $extra parameter is true
					$badge_obj->update('registration', array('Registration' => $person), true);
				}
				$activity_log->create();
				$activity_log->save(array('type' => 'membership_closed', 'custom' => $event['Event']['id']));
			}
		}

		$transaction->commit();

		$this->Lock->unlock();
	}
}
?>
